# Cascade Chat Conversation

  Note: _This is purely the output of the chat conversation and does not contain any raw data, codebase snippets, etc. used to generate the output._

### User Input

现在的功能几乎都很完美了，唯一要做的就是最后一个安全防护，，所以为了确保我们的订阅安全，只让主流的客户端如图1，如@[i:\repo\test\MiSub\README.md:L56] 这些能正确更新，正常拉取，还能保证我们当前所有功能流程不受影响，特别是里面有个订阅转换服务，通过调用后端订阅转换API它的工作正常，应该怎么办？只讨论方案，不写代码，下面是项目文件@[test/MiSub] @[test/MiSub/doc/windsurf-tutorial.md] 

### Planner Response

我先简单看一下你这个项目里目前订阅和“订阅转换 API”的实现方式，然后基于现有结构给你一个**只限主流客户端但又不影响当前所有流程**的安全方案设计（不写代码，只讲思路和折中点）。

*Updated todo list*

*Found code context*

*Viewed [README.md](file:///i:/repo/test/MiSub/README.md) *

*Viewed [windsurf-tutorial.md](file:///i:/repo/test/MiSub/doc/windsurf-tutorial.md) *

### Planner Response

我会先从你的 README 和教程文档里理解当前支持的客户端和订阅转换方式，然后再从 functions 目录里查实际的订阅/转换实现（尤其是 handleUserSubscription、一段式/二段式/三段式 URL、subconverter 调用），最后给出一个“只讨论方案、不写代码”的安全设计，不破坏现有流程。

*Viewed [README.md](file:///i:/repo/test/MiSub/README.md) *

*Viewed [windsurf-tutorial.md](file:///i:/repo/test/MiSub/doc/windsurf-tutorial.md) *

*Searched filesystem*

*Updated todo list*

*Viewed [%5B%5Bpath%5D%5D.js](file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js) *

*Updated todo list*

### Planner Response

## 目标再确认

你现在要做的是在**订阅拉取这一层**再加最后一道安全闸门：

- **只允许**主流客户端：Sing-box、Clash、Clash Meta、Stash、Surge、Loon、Surfboard、以及你面板里支持的那些格式。
- 它们要能**正常更新 / 拉取**，包含：
  - 直接拉取订阅
  - 通过“通用链接”自动识别客户端
  - 通过后端调用 `subconverter` 的整个链路（含 callback）
- 同时：
  - 不破坏现有反共享、防缓存错误节点、二段式/三段式安全校验等逻辑
  - 不影响管理后台（浏览器访问）和上游机场订阅更新 Cron

下面我只讲**设计方案**，不写具体代码。

---

## 一、先把“请求类型”分类清楚

针对订阅相关请求，可以分成 4 类：

1. **客户端拉取订阅**
   - 典型 UA 示例：
     - `Loon/xxx CFNetwork/...`
     - `Surge/xxx CFNetwork/...`
     - `Stash/xxx CFNetwork/...`
     - `Clash for Windows/0.20.xx`
     - `ClashMeta/…`
     - `sing-box-android/…`
     - `Surfboard/…`
   - 访问路径：
     - 三段式 `/publicshare/test/dcuf`
     - 通用链接 `/publicshare/test/dcuf?target=auto` 等

2. **subconverter 回调 / 二段式转换**
   - 访问路径：
     - `/publicshare/test?target=base64&callback_token=...`
   - Header：
     - 已经有 `subconverter-request: 1` 这类特殊标记
   - UA 通常是类似 `Mozilla/5.0`

3. **管理后台 / API / 静态前端**
   - 浏览器访问 ` /`, `/dashboard`, `/api/*`（登录、配置、用户管理等）
   - 必须对浏览器开放，否则后台不能用

4. **异常 / 非法 / 自制脚本**
   - 各种 curl / Python 脚本 / 抓包复制出来的订阅链接
   - UA 可能是 `curl/…`、`python-requests/…`、`Mozilla/5.0`（伪装浏览器）等

**UA 白名单只对第 1 类（订阅拉取）生效；第 2 类通过“内部标记”放行；第 3 类走原有登录认证；第 4 类一律打入“异常”逻辑，返回错误节点。**

---

## 二、核心思路：统一的“客户端识别 + 白名单”模块

### 1. 抽象一个“客户端识别器”

设计上可以认为有一个逻辑模块，输入是 `User-Agent` 和 Request headers，输出：

- `type`：
  - `client`（主流订阅客户端）
  - `browser`（Chrome/Safari/Edge 等）
  - `subconverter`（带有 subconverter 特殊 header）
  - `unknown`（其他）
- `clientName`：
  - 如 `Loon` / `Surge` / `Clash` / `Sing-box` / `Stash` / `Surfboard` 等

这个模块内部基于**可配置的正则 / 前缀匹配列表**，而不是死写在代码里，方便你以后加新客户端。

### 2. 统一配置一份“允许的客户端列表”

在设置（Settings）里扩展一个配置，比如概念上包含：

- 是否开启严格 UA 限制开关：`clientWhitelistEnabled`
- 允许的客户端枚举：`allowedClients = ['Clash', 'ClashMeta', 'Sing-box', 'Loon', 'Surge', 'Stash', 'Surfboard']`
- 是否允许“管理员调试时的浏览器绕过”：`allowAdminBrowserForDebug`

识别器得到 `clientName` 后，只要：

- `type === 'client' && clientName 在 allowedClients 中` → 允许
- 其他 → 进入后面几种特殊分支或异常处理。

---

## 三、订阅相关路径上具体怎么用这套机制

### 1. 三段式订阅 `/token/profileId/userToken`

这是所有反共享策略、设备限制、城市限制等逻辑所在的主战场。

**在现有 token 校验、反共享之前**插入一层“客户端白名单”：

1. 先判断是不是 subconverter 回调：
   - 有 `subconverter-request: 1` 或其它你现在已经用的标记 → **直接放行**，不做 UA 限制。
2. 如果不是 subconverter：
   - 调用客户端识别器:
     - 如果 `type === 'client'` 且 `clientName` 在白名单里 → 继续现有逻辑（反共享等）。
     - 如果 `type === 'browser'`：
       - 普通用户 → 直接返回“错误节点”（你现在已经有的“订阅链接异常”错误节点模式），避免 403。
       - 如果检测到当前请求带有有效管理员登录 Cookie 且在设置里打开了 `allowAdminBrowserForDebug` → 允许（方便你调试）。
     - 如果 `type === 'unknown'`：
       - 按高安全要求：直接走“错误节点”。
       - 如果你担心误伤少数“非主流但合法客户端”，可以提供一个“兼容模式”开关，让 unknown 走原逻辑。

### 2. 通用链接与“自动识别客户端”

你 README 里写了“自适应连结，可智慧识别客户端类型”，这部分实际上和 UA 白名单逻辑是同一个东西：

- 直接**复用同一个客户端识别器**：
  - 识别出 `clientName` 后，不仅用于“是否放行”，也用于决定默认 target（clash/singbox/loon 等）；
  - 这样不会有两套相互矛盾的识别规则。

在设计上就是：

- “识别器”输出 `clientName`
- 订阅主逻辑根据 `clientName`：
  - 选择默认 target / format
  - 校验是否在白名单
  - 决定是否继续后续反共享逻辑

这样可以保证“自动适配 + 白名单控制”一步到位。

### 3. 二段式 ` /publicshare/test?target=base64&callback_token=...`

这一块已经是**subconverter 专用回调**，现在你已经有：

- 通过 `subconverter-request` / `subconverter-version` 等 header，打印 `[Subconverter] Detected subconverter request, bypassing browser check`

在方案里要保证：

- **先**识别 subconverter 回调：
  - 有那几个专用 header 或 callback_token → 标记为 `type = 'subconverter'`
- 对 `type = 'subconverter'` 的请求：
  - 完全跳过 UA 白名单逻辑，进入你现在已有的 callback 处理和错误节点保护逻辑。
- 这样：
  - 你的“订阅转换服务”完全不受影响；
  - subconverter 用什么 UA（哪怕就是 `Mozilla/5.0`）都不会被当成浏览器拦截。

### 4. 管理后台 & API

对 `/api/*` 和前端 SPA 的静态资源：

- 不走“客户端白名单”逻辑，只走现有的 Cookie 登录认证；
- 避免对浏览器做任何额外限制。

---

## 四、防绕过和兼容性平衡

UA 白名单本质上**只能防住大部分非技术用户和误用**，不能防完全伪造 UA 的人。所以建议你把它当作“最后一道软防线 + 体验优化”，与现有反共享机制配合使用：

1. **和反共享配合**
   - 白名单挡住“直接用浏览器访问 / 工具乱拉”的大头；
   - 剩下真有心伪造 UA 的人，还得靠设备数/城市数/访问次数这些硬检测。

2. **兼容性策略**
   - 提供两个模式：
     - “严格模式”：只有识别出的主流客户端放行，其他全部错误节点。
     - “兼容模式”：主流客户端直接放行；`unknown` 走原逻辑，仅浏览器被强制错误节点。
   - 刚上线时建议先用“兼容模式”，观察一段时间 Cloudflare 日志，看是否有合法客户端被识别为 unknown，再决定是否切换到严格模式。

3. **管理员调试通道**
   - 通过登录 Cookie + 设置里的一个开关，允许你用浏览器直接访问订阅链接调试（仅你自己），普通用户没有这个能力。

---

## 五、对现有流程的影响检查

- **不会影响**：
  - `subconverter` 调用（通过专用 header 完全旁路 UA 检查）
  - 二段式 callback 流程
  - 管理后台所有功能
  - 上游机场订阅定时拉取（Cron 那部分是服务器主动请求，不受这个入口限制）

- **增强的地方**：
  - 普通用户用浏览器打开订阅链接时：
    - 不再看到节点列表，而是你现在已有的“错误节点”（本地 127.0.0.1 的假节点），缓存也失效。
  - 非主流客户端或脚本工具（curl/requests）：
    - 在严格模式下也会只拿到错误节点，不能无脑共享。

---

## 总结

- 利用一套**统一的“客户端识别 + 白名单”模块**，在订阅入口层面区分主流客户端 / subconverter / 浏览器 / 其他。
- **对订阅拉取 URL**（三段式、通用链接）开启白名单：只有识别为主流客户端才放行，其余走“错误节点”。
- **对 subconverter 回调**通过专用 header 完全豁免 UA 限制，确保订阅转换服务 100% 不受影响。
- 提供“严格/兼容模式 + 管理员调试开关”，在安全与兼容性之间可控地折中。

如果你愿意，下一步我可以根据这个方案，帮你在 `[[path]].js` 里标出“应该插入逻辑的具体位置”和需要新增的配置字段（依然可以只讲思路、不写实现代码）。

*Viewed [%5B%5Bpath%5D%5D.js](file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js) *

### User Input

@[i:\repo\test\MiSub\functions\[[path]].js:L3575-L3744] 当前已有的方案能达到这种效果吗？我觉得不要太复杂，可以按照你刚才说的思路，对已有的进行优化也可以，

### Planner Response

我先看看 [isBrowserAccess](cci:1://file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js:3574:0-3588:1) 在后端是怎么被调用的，确认现在这套逻辑到底拦住了哪些情况、放过了哪些情况，然后再回答你“是否已经达到预期效果”和“在不变复杂的前提下如何优化”。只讨论方案，不改代码。

*Grep searched codebase*

*Viewed [%5B%5Bpath%5D%5D.js](file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js) *

### Planner Response

## 先直接回答你的问题

- **现在这一套 `isBrowserAccess + getBrowserBlockedResponse` 已经做到：**
  - 三段式 `/token/profileId/userToken` 里：
    - 先走 `isBotRequest`（拦掉爬虫）
    - 再走 [isBrowserAccess(userAgent)](cci:1://file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js:3574:0-3588:1)
    - 命中则直接返回你那段 HTML 提示页（不返回节点）
  - 二段式 `/publicshare/test` 里：
    - 有 `subconverter-request: 1` 的回调请求会被识别为 subconverter，**提前绕过浏览器检查**
    - 其它请求再走 [isBrowserAccess(userAgentHeader)](cci:1://file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js:3574:0-3588:1)，命中也同样返回 HTML 提示页  
- **效果上：**
  - 用 Safari / Chrome 直接打开订阅链接 → 命中 `browserKeywords` 且 UA 不含 `proxyClientKeywords` → 被判定为浏览器 → 返回 HTML 提示页 ✅
  - 用 Loon / Surge / Clash / Stash 等客户端：
    - UA 里包含 `loon` / `surge` / `clash` / `stash` 等代理关键字
    - 即使 UA 中有 `mozilla`，因为 `proxyClientKeywords.some(...)` 为 true，所以 [isBrowserAccess](cci:1://file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js:3574:0-3588:1) 返回 false → 正常拉取 ✅
  - subconverter 回调（带 `subconverter-request` 头）：
    - 在主逻辑里已经有“Detected subconverter request, bypassing browser check”
    - 不会经过 [isBrowserAccess](cci:1://file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js:3574:0-3588:1) → 不受限制 ✅  

**总结：就“拦掉浏览器 + 放行主流客户端 + 保证 subconverter 正常工作”这三点来说，当前方案已经基本达到了你想要的效果。**

---

## 但它还没做到的地方（跟你刚才“只让主流客户端”那层比）

现在这套逻辑本质上是：

- **黑名单：浏览器 UA**  
  - 满足「包含浏览器关键字」且「不包含代理关键字」才算“浏览器”，被拦。
- **但对于以下都不会拦：**
  - `curl/7.x`
  - `python-requests/2.x`
  - 各种自制爬虫 / 脚本，只要 UA 里没有 `mozilla/chrome/safari/...`
- 也就是说：
  - 它做的是“**禁止浏览器直接打开**”，而不是严格意义上的“**只允许这些客户端，其它一律不行**”。

如果你能接受“脚本类 UA 依然可以拉订阅”，那现在这套已经够用，只需要把关键字维护好就行。

---

## 按你“不要太复杂”的要求，怎么在现有基础上优化

我按“**最少改动、复用现有逻辑**”来提方案，只讲思路不写代码：

### 1. 把 `proxyClientKeywords` 精准化成“白名单客户端列表”

现在的 `proxyClientKeywords` 里有一堆历史客户端（shadowrocket、quantumult、v2rayn…），你真正想保证的主流是：

- Sing-box
- Clash / Clash Meta
- Stash
- Surge
- Loon
- Surfboard
- 以及你 README 里提到要重点支持的那几个

可以做的事：

- **清理 / 补全 `proxyClientKeywords`：**
  - 保留你现在仍想支持的主流客户端关键字（clash、loon、surge、stash、surfboard、sing-box 等）
  - 给 Sing-box、Clash Meta 补上更准确的标识（例如 `sing-box`、`mihomo` / `meta` 等）
- 这样一来：
  - 只要 UA 里带这些关键字，就一定**不会被当成浏览器拦**。
  - 你的“支持的客户端列表”就是这组关键字，逻辑简单、维护点也可视。

### 2. 轻量增加一层“非浏览器 UA 的白名单判断”（可选）

如果你希望再进一步，接近“只让主流客户端”：

- 在 [isBrowserAccess](cci:1://file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js:3574:0-3588:1) 之外，再抽一个很简单的逻辑，例如概念上的 `isSupportedClient(userAgent)`：
  - 内部就用同一组 `proxyClientKeywords` 去匹配。
- 在三段式 / 二段式订阅处理里（在排除 subconverter 之后）加一条判断：
  - 如果：
    - 不是 subconverter 请求  
    - 也没被识别为浏览器（`!isBrowserAccess`）  
    - 又 `!isSupportedClient(userAgent)`  
  - 那就走你现在已经有的“错误节点返回模式”（而不是 403），让这些脚本类请求也拿不到真实节点。

这样改动的特征：

- **复用现有数组和模式**，没有新一套复杂“客户端识别器”；
- 逻辑走向还是三步：
  - 先判断 subconverter → 直接放行
  - 再判断浏览器 UA → 返回 HTML 提示页
  - 最后判断是否在支持的客户端列表 → 否则返回错误节点
- 配合你现有的反共享、错误节点、admin_key 逻辑，整体结构不会乱。

---

## 结论

- **现在这一版 `isBrowserAccess + getBrowserBlockedResponse`：**
  - 已经能做到：
    - 浏览器打开订阅 → 不给节点，只给 HTML 提示页；
    - 主流代理客户端（在 `proxyClientKeywords` 里的）→ 不受影响；
    - subconverter → 走专门的 bypass，不受限制。
- 如果你只想要“防止用户在浏览器/社交软件里乱点订阅链接”，**当前方案已经达标，只需要维护好 `proxyClientKeywords`**。
- 如果你还想进一步限制脚本 / 其他非主流客户端，在不变复杂的前提下，可以：
  - 把 `proxyClientKeywords` 视为“白名单”
  - 再加一条“非浏览器 UA 也必须命中这个白名单，否则返回错误节点”的轻量判断。

如果你愿意，下一步我可以帮你逐一列出**主流客户端的实际 UA 样例**，告诉你 `proxyClientKeywords` 应该具体包含哪些字符串，保证“不误杀主流，同时尽量缩小漏网之鱼”。

### User Input

不接受脚本类 UA 依然可以拉订阅，

（shadowrocket、quantumult、v2rayn…），这类我也要保留，几乎要达成只增不减的思想，尽量涵盖到更多客户端

也就是说后期我只需要维护这些关键字吗？直接加上对应客户端的名字就行？你的“支持的客户端列表”就是这组关键字，逻辑简单、维护点也可视。

我的疑问就这些

### Planner Response

## 先回答你两点核心疑问

### 1.「不接受脚本 UA 还能拉订阅」能做到吗？

可以做到，而且基于你现有这套 [isBrowserAccess](cci:1://file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js:3574:0-3588:1) 继续扩展就行，思路是：

1. **浏览器**  
   - 继续用现在的 [isBrowserAccess(userAgent)](cci:1://file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js:3574:0-3588:1) 判定  
   - 命中 → 返回 HTML 提示页（当前已经 OK）

2. **脚本 / 未知 UA**  
   - 额外再做一层：  
     - 不是 subconverter 请求  
     - `!isBrowserAccess(ua)`（即不是浏览器）  
     - 并且 UA **不包含任何“已知代理客户端关键字”**  
   - 满足这三个条件 → 直接返回“错误节点”（你现在已经用的 127.0.0.1 模糊错误）

3. **代理客户端**  
   - UA 中只要包含你维护的任意一个客户端关键字  
   - 即使带 `Mozilla` 也会被判定为“代理客户端”，**不会被当作浏览器拦**，也不会被脚本那条拦  
   - 继续正常走现有的订阅/反共享逻辑

4. **subconverter**  
   - 保留现在的 `subconverter-request: 1` 等标记，**在一切 UA 判断之前就直接放行**  

这样脚本类 UA（curl / python-requests / 各种自写脚本）既不在浏览器列表，也不在客户端关键字列表，就会被第二层“未知 UA 拦截”挡掉，拿不到真实节点。

---

### 2. 以后是不是「只需要维护这些关键字」就够了？

在上面这种设计下，可以理解为：

- **是的，原则上你只需要维护这一份“客户端关键字列表”，就是你的“支持客户端白名单”。**

但有几个小注意点：

1. **只增不减的语义**  
   - 默认策略变成：  
     - 不在关键字列表里的，统统当作“不支持客户端”处理（脚本/未知 UA），直接错误节点。  
   - 你后面新增一个客户端，只要把它 UA 里独有的那段字符串加到列表里，这个客户端就自动放行。  
   - 所以实现上确实是“只增不减”的维护方式。

2. **关键字要尽量“专一”**  
   - 对每个客户端，挑**尽量不通用**的片段：
     - `shadowrocket`
     - `quantumult` / `quantumult x`
     - `surge`
     - `loon`
     - `clash` / `clashmeta` / `mihomo`
     - `stash`
     - `sing-box`
     - `surfboard`
     - `v2rayn` / `v2rayng`
     - ……
   - 不建议用太宽泛的，如 `vpn`、`proxy` 这种，避免脚本随便写个 UA 就撞进白名单。

3. **一个客户端可以有多个关键字**  
   - 比如 Clash 相关：
     - Windows：`Clash for Windows`
     - Meta：`ClashMeta`、`mihomo`
     - 手机端：可能用其它标识  
   - 可以为同一类客户端维护多个关键词，只要任意一个命中就放行。

4. **新增客户端时的步骤很简单**  
   后期真的要加一个新客户端，大概只需要：

   - 在日志里看一眼它真实的 UA（Cloudflare 日志里有）
   - 找一个稳定且不太通用的子串
   - 加到 `proxyClientKeywords` 这类数组里  
   然后重新部署就生效了，不需要动其它逻辑。

5. **仍然无法防“伪装 UA 的人”**  
   - 只要有人故意把脚本 UA 写成 `ClashMeta/1.0` 之类，你是识别不出来的，这属于任何 UA 方案的共性问题。  
   - 但对于绝大多数非技术用户 + 普通脚本，这个方案已经足够“挡住脚本、放行客户端”。

---

## 小结

- 通过在现有 [isBrowserAccess](cci:1://file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js:3574:0-3588:1) 基础上再加一层“非浏览器 UA 的客户端白名单判断”，**脚本类 UA 可以完全拦掉**，只给错误节点。
- 你要保留的 shadowrocket / quantumult / v2rayn 等，都通过维护同一份 `proxyClientKeywords` 列表来放行。
- 以后新增客户端时，你基本上只需要：
  - 看它的 UA
  - 把对应关键字加进这份列表  
  其他逻辑不用动。

如果你愿意，下一步我可以帮你整理一份「**常见客户端 UA 示例 + 推荐关键字清单**」作为维护参考。

### User Input

可以的整理吧，然后如果要写代码的可以开工了

### Planner Response

我先帮你整理一份「常见客户端 UA 示例 + 推荐关键字」清单，然后在不改动你已有注释风格的前提下，按我们刚才讨论的思路在 `[[path]].js` 里实现：在三段式订阅入口增加“仅白名单客户端 + 拦截脚本 UA”的逻辑，同时保持 subconverter、二段式回调等流程不受影响。接下来我会先查一下目前文件里错误节点复用的位置，然后开始动代码（不会在回复里贴代码，只直接改文件）。

*Updated todo list*

*Viewed [%5B%5Bpath%5D%5D.js](file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js) *

*Viewed [%5B%5Bpath%5D%5D.js](file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js) *

*Grep searched codebase*

*Grep searched codebase*

*Viewed [%5B%5Bpath%5D%5D.js](file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js) *

*Viewed [%5B%5Bpath%5D%5D.js](file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js) *

### Planner Response

我先给你整理一份主流客户端的 UA 关键字清单，方便你后续只维护这一份列表。然后我会在 `[[path]].js` 里按我们刚才说的思路真正动手：  
- 把代理客户端关键字提取成一个统一数组；  
- 新增一个 `isSupportedProxyClient` 帮你判断“是否在白名单”；  
- 在三段式订阅的 [handleUserSubscription](cci:1://file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js:3744:0-4289:1) 里，在 bot 检测和浏览器检测之后，对“非白名单 UA”直接返回错误节点，从而拦掉脚本。  

我会直接修改文件，不在回复里贴代码。改完后再简单说明改动点，方便你 review。

*Edited relevant file*

### Planner Response

我已经把代理客户端关键字抽成了一个全局常量，并增加了 [isSupportedProxyClient](cci:1://file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js:3591:0-3594:1)。接下来我会在 [handleUserSubscription](cci:1://file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js:3750:0-4295:1) 里，在 bot 检测之后、浏览器检测之前，加一层“非浏览器且非白名单 UA → 返回错误节点”的逻辑，这样脚本类 UA 也拿不到真实节点。改好后再给你总结关键字清单和逻辑位置，方便你后面维护。

*Edited relevant file*

### Planner Response

我已经按我们讨论的方案把代码改好了，现在整理一份常见客户端 UA 关键字清单，并说明目前逻辑、以后维护方式，你可以直接对照测试。

*Updated todo list*

### Planner Response

## 一、常见客户端 UA 关键字清单（“白名单”）

现在代码里有一个全局常量：

```js
const proxyClientKeywords = [
  'shadowrocket', 'quantumult', 'surge', 'loon', 'clash', 'stash', 'pharos',
  'v2rayn', 'v2rayng', 'kitsunebi', 'i2ray', 'pepi', 'potatso', 'netch',
  'qv2ray', 'mellow', 'trojan', 'shadowsocks', 'surfboard', 'sing-box', 'singbox'
];
```

这些就是**被视为“支持的订阅客户端”的关键字列表**。只要 UA 里包含其中任意一个小写关键字，就会认为是“代理客户端”。

下面是你后面维护时可以参考的映射（UA 示例是常见形式，关键字以实际为准）：

- **Shadowrocket**  
  - 常见 UA 样式：`Shadowrocket/xxxx CFNetwork/...`  
  - 关键字：`shadowrocket`

- **Quantumult / Quantumult X**  
  - 常见 UA：`Quantumult%20X/xxxx`  
  - 关键字：`quantumult`（同时覆盖旧版和 X）

- **Surge**  
  - UA：`Surge/xxxx CFNetwork/...`  
  - 关键字：`surge`

- **Loon**  
  - UA：`Loon/904 CFNetwork/...`  
  - 关键字：`loon`

- **Clash / Clash Meta / CFW**  
  - UA：`Clash for Windows/0.20.x`、`ClashMeta for Windows/...` 等  
  - 关键字：`clash`（覆盖大部分带 Clash 字样的客户端）  
  - 如果以后发现有只写 `mihomo` 的 UA，可以再额外加 `'mihomo'`

- **Stash**  
  - UA：`Stash/xxxx CFNetwork/...`  
  - 关键字：`stash`

- **Surfboard**  
  - UA：`Surfboard/xxxx CFNetwork/...`  
  - 关键字：`surfboard`

- **Sing-box**  
  - UA 里常见：`sing-box/1.x`  
  - 关键字：`sing-box`、`singbox`（两种写法都支持）

- **V2RayN / V2RayNG**  
  - 关键字：`v2rayn`、`v2rayng`

- **其它老牌客户端**  
  - **Kitsunebi**：`kitsunebi`  
  - **i2Ray**：`i2ray`  
  - **Pepi / Potatso / Netch / Qv2ray / Mellow**：对应关键字  
  - **通用协议类**：`trojan`、`shadowsocks`（部分客户端 UA 里会带）

> 以后如果你想支持新的客户端，只需要在这个数组里**追加一个能唯一识别它的子串**即可，不用动其它逻辑。

---

## 二、当前后端行为总结（重点看三段式订阅）

### 1. [handleUserSubscription](cci:1://file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js:3750:0-4308:1)（三段式 `/token/profileId/userToken`）

现在顺序是：

1. **callback_token 检查**  
   - 如果是 subconverter 回调（`callback_token` 正确），直接走回调分支 → 返回节点列表给 subconverter。  
   - 这一支对 UA 不做任何限制 ✅

2. **Bot 检测**  
   - 用 `asyncConfig.botDetection.BOT_KEYWORDS` 做正则，命中就返回 403 文本，不给节点 ✅

3. **脚本 / 未知 UA 拦截（新加的 0.4 步）**  
   - 取 `User-Agent`：
     - 如果 **不是浏览器**：`!isBrowserAccess(userAgent)`  
     - 且 **也不是支持的代理客户端**：`!isSupportedProxyClient(userAgent)`  
   - 满足这两个条件 → 视为脚本 / 未知客户端：  
     - 直接返回你之前定义的 `订阅链接异常` 错误节点（127.0.0.1）  
     - 不走后面的反共享 / 节点生成逻辑  
   - 这样 `curl` / `python-requests` / 自写脚本 UA 全部只能拿到错误节点 ✅  

4. **浏览器访问拦截（0.5）**  
   - [isBrowserAccess(userAgent)](cci:1://file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js:3578:0-3589:1) 为 true（浏览器 UA 且不含任何代理关键字）：
     - 返回 [getBrowserBlockedResponse()](cci:1://file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js:3596:0-3748:1) 的 HTML 引导页  
     - 不返回节点 ✅  

5. **其余逻辑不变**  
   - 通过以上几层检查后，才去验证 profileToken、加载用户数据、做过期检查、反共享等。

### 2. `/sub/...` 主入口里的二段式

主入口里有：

- `isSubconverterRequest`：  
  - 有 `subconverter-request` / `subconverter-version` / `callback_token` 就视为 subconverter，打印日志并**绕过浏览器检测**，保证转换服务正常；

- 二段式 `/publicshare/test` 已经有基于 `admin_key` / `callback_token` 的保护逻辑，未授权访问会返回**错误节点**，和 UA 无关，这一块安全策略保持不变。

---

## 三、后续你只需要维护什么？

可以理解为**两份东西**需要维护：

1. **代理客户端关键字列表 `proxyClientKeywords`**  
   - 这就是你要“只增不减”的主刀位置。  
   - 想支持新客户端时：
     - 去 Cloudflare 日志里看它真实 UA
     - 找一个较独特的小写子串
     - 加进数组 → 重新部署

2. **Bot 关键字（在 `asyncConfig.botDetection.BOT_KEYWORDS` 内）**  
   - 如果以后有新爬虫，可以在那里加关键字，提前挡掉。

> 脚本类 UA 不再能拉订阅：只要它的 UA 既不像浏览器、又不包含任何上述客户端关键字，就会直接拿到“订阅链接异常”的错误节点。

---

## 四、状态小结

- 已经把代理客户端关键字抽成全局列表，并加上 [isSupportedProxyClient](cci:1://file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js:3591:0-3594:1)。
- 在三段式订阅中添加了“非浏览器且不在代理列表 → 返回错误节点”的保护，脚本 UA 会被彻底挡住。
- subconverter 回调和二段式 admin_key / callback_token 逻辑保持原样，不受影响。

你接下来可以用几种 UA 做一下实际测试（Loon、Surge、Clash、Sing-box、curl），如果有某个真实客户端 UA 没被识别出来，我们再根据日志帮你挑一个更合适的关键字补进去。

*Edited relevant file*

*Viewed [anti-share-config.js](file:///i:/repo/test/MiSub/functions/anti-share-config.js) *

### User Input

发现一个问题，我其中一个订阅组，明确设置@[i:\repo\test\MiSub\functions\anti-share-config.js:L76-L93] 这个预设，但实际访问来看IP 地址: 203.10.99.210
国家: 🇯🇵 Japan
城市: Tokyo
街道: Japan
ISP: GSL Networks Pty LTD
ASN: N/A
数据来源: ipgeolocation.io

域名: subhub.tsmoe.com
客户端: NekoBox/Android/1.4.1 (Prefer ClashMeta Format)
Token: wzpb2r86iicc4zws
订阅组: elexplan
状态: ✅ activated
总访问次数: 11
上次访问: 2025/11/14 18:30:41
到期时间: 2026/11/14 06:39:00

时间: 2025/11/14 18:30:41 (UTC+8)

如图2，访问了这么多次，都没触发访问4个设备的上限返回错误节点，这里还不是封禁状态，只是返回错误节点，如果返回错误后还一直访问，达到这个值@[i:\repo\test\MiSub\functions\anti-share-config.js:L91] 才触发临时封禁，请你看看哪里有问题

### Planner Response

我需要先把这条订阅访问对应的反共享配置和设备上限检测逻辑完整捋一遍，看看 `pro` 预设（4 设备）在代码里是怎么应用的，以及当前用户的设备数、失败计数是如何累积的。然后我会解释：为什么在设备数=4 时仍然没有返回错误节点，是设计就是“>4 才拦”，还是存在逻辑/调用条件问题。接下来我会去查 [performAntiShareCheck](cci:1://file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js:2736:0-3572:1) 相关代码和日志打印位置。

*Updated todo list*

### Planner Response

我先去把反共享核心逻辑 [performAntiShareCheck](cci:1://file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js:2736:0-3572:1) 找出来，看在“设备数检测”那里到底是用 `>` 还是 `>= MAX_DEVICES`，以及是在什么条件下才返回错误节点 / 计为失败。然后再对照你发的这位用户的设备数和访问记录，判断是逻辑本身就是“第 5 台才拦”，还是配置或调用出了问题，再给你明确结论。

*Grep searched codebase*

### Planner Response

我先把反共享核心函数 [performAntiShareCheck](cci:1://file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js:2736:0-3572:1) 的实现和“设备上限”相关的那一段完整看一遍，再看它是怎么从 profile 的 `policyKey` 选到 `pro` 预设，并在用户这条订阅访问路径里被调用。这样才能判断：现在的行为是不是按“第 5 台设备才算违规”设计的，还是某一步根本没有按 `pro` 预设执行。看完我会先给你一个结论：这是逻辑预期不同，还是确实有 bug。

*Grep searched codebase*

### Planner Response

我需要先把 [performAntiShareCheck](cci:1://file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js:2736:0-3572:1) 里“设备数超限”的具体判断条件看清楚（是 `>` 还是 `>=`），以及它什么时候才会返回错误节点并累计失败次数，然后再对照你这个订阅组的实际设备数和访问情况，判断是逻辑预期就是这样，还是哪里有实现问题。接下来我会打开这段函数代码分析。

*Viewed [%5B%5Bpath%5D%5D.js](file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js) *

*Viewed [%5B%5Bpath%5D%5D.js](file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js) *

### Planner Response

## 先说结论

从当前代码来看，你这个订阅组 **“没有触发设备上限返回错误节点”是符合现有逻辑的**，不是配置失效，而是「设备上限是从第 5 台开始判违规」，前 4 台都是允许的。

你看到的：

- 预设 `pro`：`MAX_DEVICES: 4`
- 用户详情里：设备数 = `4`
- 访问很多次都正常

这是因为当前实现是：

> 只有当**第 5 台新设备**来访问时，才会返回错误节点并累计失败次数，前 4 台设备是合法的额度。

---

## 代码里设备上限的真实判断逻辑

[performAntiShareCheck](cci:1://file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js:2736:0-3572:1) 中关键部分（你刚打开的那段）：

```js
const isNewDevice = !userData.devices[deviceId];
const deviceCount = Object.keys(userData.devices).length;

// 【检测1】设备数量限制（新设备才检查）
if (isNewDevice && deviceCount >= config.antiShare.MAX_DEVICES) {
    // 这里才算“超限”
    // 1. failedAttempts++ （失败次数）
    // 2. 如果 failedAttempts >= SUSPEND_FAILED_ATTEMPTS_THRESHOLD → 临时封禁
    // 3. 否则 allowed: false, reason: 'device_limit' → 返回错误节点
}
```

注意两点：

1. `deviceCount` 是**已有设备数量（旧设备数）**，不包含当前这个新设备。
2. 只有 `isNewDevice === true` 时才会进入设备上限检测。

以 `MAX_DEVICES = 4` 为例：

| 当前已有设备数 `deviceCount` | 本次访问是第几台设备 | 条件 `isNewDevice && deviceCount >= 4` | 结果 |
|-----------------------------|----------------------|-----------------------------------------|------|
| 0 | 第 1 台 | `true && 0 >= 4` → false | 允许 |
| 1 | 第 2 台 | `true && 1 >= 4` → false | 允许 |
| 2 | 第 3 台 | `true && 2 >= 4` → false | 允许 |
| 3 | 第 4 台 | `true && 3 >= 4` → false | 允许 |
| 4 | 第 5 台 | `true && 4 >= 4` → true | **视为超限，返回错误节点** |

也就是说：

- **最多允许 4 台不同设备/客户端**  
- 从**第 5 台**开始才会：
  - 返回错误节点（`reason: 'device_limit'`）
  - `failedAttempts++`
  - 当失败次数 `>= SUSPEND_FAILED_ATTEMPTS_THRESHOLD`（你这个预设是 5）时，再进入临时封禁逻辑。

`SUSPEND_RATE_LIMIT_ATTEMPTS_THRESHOLD: 8` 是给**访问频率（限流）那块用的**，跟“设备数超限”是两条独立路径，你理解的「错误节点 5 次封禁 / 错误节点 8 次封禁」大致方向对，只是：  
- 设备超限用的是 `failedAttempts` + `SUSPEND_FAILED_ATTEMPTS_THRESHOLD`  
- 频率超限用的是 `rateLimitAttempts` + `SUSPEND_RATE_LIMIT_ATTEMPTS_THRESHOLD`（在后面的上游访问次数检测里）

---

## 套到你这个用户的情况

你这个订阅组（Elite-Exclusive Plan / `pro`）配置：

- `MAX_DEVICES: 4`
- `SUSPEND_FAILED_ATTEMPTS_THRESHOLD: 5`
- `SUSPEND_RATE_LIMIT_ATTEMPTS_THRESHOLD: 8`

用户当前状态：

- 设备数：`4`
- 城市数：`4`
- 状态：已激活
- 访问次数：11
- UA：`NekoBox/Android/1.4.1 (Prefer ClashMeta Format)`

按现在代码的语义：

- 这 4 台设备（4 个不同 `deviceId`，也就是 4 个不同 UA 组合）都是合法额度内的设备。  
- 你**只要继续在这 4 台设备上访问**，不会触发设备上限逻辑，因为 `isNewDevice = false`。  
- 只有当**第 5 台新设备/客户端**来更新订阅时（一个新的 UA，算作新的 `deviceId`），才会：
  - 直接收到错误节点（不是封禁，只是错误节点）  
  - `failedAttempts`++  
  - 累积到 5 次以后才会进入临时封禁。

所以，目前“访问了很多次都没返回错误节点”，说明两件事：

1. 你现在还没有出现「第 5 台新设备」来访问，仍在 4 台额度内。  
2. 或者第 5 台的 UA 和前面某台完全一样，被当成同一个 `deviceId`，所以对系统来说仍然是“旧设备访问”。

---

## 如果你的期望不一样，怎么调整

你口头描述的是：

> “访问 4 个设备的上限返回错误节点，然后再继续访问累计到 8 次才封禁。”

这有两种理解：

1. **现在实现的含义**（代码实际行为）：  
   - “最多 4 台设备是合法额度”  
   - 第 5 台开始才是“超限并返回错误节点”

2. **你可能想要的含义**：  
   - “最多只能有 3 台设备，第 4 台就算超限”  
   - 那就需要：
     - 逻辑上把条件改成：`deviceCount >= (MAX_DEVICES - 1)`；或  
     - 配置上把 `MAX_DEVICES` 设成 3（UI 文案需要同步改）。

现在代码严格执行的是第 1 种。

---

## 建议你下一步怎么验证

如果你想确认设备上限逻辑确实工作，可以：

1. 在这个订阅组下，再用**一个全新的客户端**（不同 UA）拉一次订阅，确保真的是第 5 台：
   - 比如前面已经有 Clash / Loon / NekoBox / Surge，再加一个 Shadowrocket。
2. 拉订阅后看：
   - 用户详情里的设备数是否仍是 4（因为第 5 台会被拒绝，不会记入设备列表）；  
   - 日志中是否出现 `reason: 'device_limit'` 或者 “设备数超限”的通知；  
   - 客户端是否拿到了“订阅链接异常”的错误节点。

如果你希望**调整为第 4 台就算违规**，可以告诉我你希望的具体规则（允许几台、从第几台开始错误节点），我可以帮你基于当前实现设计一版改动方案。  

---

## 顺带一提：NekoBox / Mihomo 关键字

你刚刚在 `proxyClientKeywords` 里加了 `'NekoBox', 'Mihomo'`，但代码里是把 UA 先 `toLowerCase()` 再匹配，因此这两个关键字应该写成小写：`'nekobox'`、`'mihomo'` 才会真正生效。这一点可以稍后顺手改一下。

*Viewed [anti-share-config.js](file:///i:/repo/test/MiSub/functions/anti-share-config.js) *

### User Input

@[i:\repo\test\MiSub\functions\anti-share-config.js:L82-L87] 着你这么说，我这里就没有存在的意义了，这些配置

### Planner Response

我先确认一下 `RATE_LIMITS` 在代码里的实际用法，看它是不是在访问频率（限流）那一块仍然起作用，然后再回答你这些配置现在还有没有意义，哪些是真正在用的。

*Grep searched codebase*

*Viewed [%5B%5Bpath%5D%5D.js](file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js) *

### Planner Response

我先把 `RATE_LIMITS` 在后面是怎么真正用掉的看完整，确认访问频率那块的完整流程，然后再回答你这组配置现在“有没有意义”、以及在什么情况下才会被触发。

*Viewed [%5B%5Bpath%5D%5D.js](file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js) *

### Planner Response

## 这组 `RATE_LIMITS` 其实是“访问频率上限”，不是白写的

你现在看到的这段：

```js
// 精英独家专享版：宽松限制
pro: {
  MAX_DEVICES: 4,
  MAX_CITIES: 10,
  CITY_CHECK_START_INDEX: 2,
  RATE_LIMIT_ENABLED: true,
  RATE_LIMITS: {
    1: 3,
    2: 5,
    3: 7,
    4: 9
  },
  SUSPEND_ENABLED: true,
  SUSPEND_REQUIRE_MAX_DEVICES: false,
  SUSPEND_DURATION_DAYS: 3,
  SUSPEND_RATE_LIMIT_ATTEMPTS_THRESHOLD: 8,
  SUSPEND_FAILED_ATTEMPTS_THRESHOLD: 5
}
```

对应的代码位置在 [performAntiShareCheck](cci:1://file:///i:/repo/test/MiSub/functions/%5B%5Bpath%5D%5D.js:2736:0-3572:1) 的「检测3：访问次数限制」里。

### 1. `RATE_LIMITS` 实际怎么用的？

关键逻辑（你刚看到的那段）：

```js
const currentDeviceCount = Object.keys(userData.devices).length;

// 每天重置
if (!userData.stats.dailyDate || userData.stats.dailyDate !== today) {
  userData.stats.dailyCount = 0;
  userData.stats.dailyDate = today;
  userData.stats.failedAttempts = 0;
  userData.stats.rateLimitAttempts = 0;
}

const rateLimit = config.antiShare.RATE_LIMITS[currentDeviceCount] || 999;
```

- `currentDeviceCount`：当前账号下已绑定设备数（1~4）。
- `RATE_LIMITS`：**当前设备数 → 当天允许的最大访问次数**。
  - `1: 3` → 只有 1 台设备时，每天最多 3 次订阅拉取。
  - `2: 5` → 2 台设备时，每天最多 5 次。
  - `3: 7`
  - `4: 9`

后面两步：

#### a) 封禁判定（3.1）

```js
const rateLimitAttemptsThreshold = config.antiShare.SUSPEND_RATE_LIMIT_ATTEMPTS_THRESHOLD;
// ...
const suspendByRateLimitAttempts = rateLimitAttempts >= rateLimitAttemptsThreshold;
```

- 当账号已经**达到频率上限后**，继续有人拉订阅，就会：
  - `rateLimitAttempts++`
  - 一直累积，直到 `rateLimitAttempts >= 8`（你这个 pro 预设）  
  - 满足时触发封禁（“达到上限后仍持续访问”被当作共享迹象）。

#### b) 当天访问超限 → 直接返回错误节点（3.2）

```js
if (userData.stats.dailyCount >= rateLimit) {
  userData.stats.rateLimitAttempts++;
  // 发 “访问次数超限” 通知
  return {
    allowed: false,
    reason: 'rate_limit',
    dailyCount: userData.stats.dailyCount,
    rateLimit,
    // ...
  };
}
```

也就是说：

- **当天第 1~rateLimit 次访问**：正常通过。
- **当 `dailyCount >= rateLimit` 时的下一次访问**：
  - 返回 `reason: 'rate_limit'`，对应你的错误节点（而不是 403）。
  - 同时 `rateLimitAttempts++`，为后续封禁做计数。

### 2. 和你看到的用户数据怎么对上？

你看到的：

- 总请求数：`13`（UI 的“总请求数”是 lifetime 的 totalRequests，不是当天的 dailyCount）
- 当前设备数：`4`
- 对 `pro` 预设：当前 `rateLimit = RATE_LIMITS[4] = 9`

所以当天的行为是：

- 第 1~9 次访问：通过  
- 第 10 次访问（当天）起：进入 `rate_limit` 分支，返回错误节点  
- 每次超限访问 `rateLimitAttempts++`，到第 8 次超限访问，会触发封禁逻辑。

如果你现在还没看到“访问次数超限”日志，很可能是：

- 当天的 `dailyCount` 还没超过 9（或者刚换日重置过），**不是总请求 11 次**的问题。

### 3. 所以这组配置有什么意义？

总结一下：

- `MAX_DEVICES` 控制的是**允许的设备数量**（前 4 台合法，第 5 台算超限）。
- `RATE_LIMITS` 控制的是**整账号的日访问次数上限**，根据设备数自动变化：
  - 设备越多，每天允许的总拉取次数越多，但仍有限制。
- `SUSPEND_RATE_LIMIT_ATTEMPTS_THRESHOLD` 控制：  
  - “在已经超限的前提下，继续尝试的次数”，超过 8 次就封禁。

它们是“**设备数上限**”和“**访问频率上限**”两套机制，都是在用的，只是触发条件不一样。

---

### 4. 什么时候会“明显感受到 RATE_LIMITS 生效”？

对当前 `pro` 预设：

- 某用户绑定了 4 台设备  
- 当天第 10 次（及以后）刷新订阅：
  - 客户端拿到的是错误节点（`reason: 'rate_limit'`）
  - 日志里会有“访问次数超限”的记录  
- 如果还继续刷，达到 8 次超限尝试：
  - 进入封禁分支，按 3 天封禁。

---

如果你希望把“访问次数限制”调得更激进（比如 4 台设备每天只允许 5 次），只需要改 `pro.RATE_LIMITS[4]` 即可，不用动代码逻辑。